/*
JSCAD Object to AutoCAD DXF Entity Serialization

## License

Copyright (c) 2018 Z3 Development https://github.com/z3dev

All code released under MIT license
*/

const {isCAG, isCSG} = require('@jscad/csg')
const {dxfHeaders, dxfClasses, dxfTables, dxfBlocks, dxfObjects} = require('./autocad_AC2017')

const mimeType = 'application/dxf'

/**
 * Notes:
 * 1) TBD support binary output
 * 2) TBD add color conversion, and translation for CSG
 * 3) CAG conversion to:
 *      POLYLINE
 *      LWPOLYLINE
 * 4) CSG conversion to:
 *      3DFACE
 *      POLYLINE (face mesh)
 * 5) Path2D conversion to:
 *      LWPOLYLINE
 */
const serialize = function (objects, options) {
  const defaults = {
    cagTo: 'lwpolyline', // or polyline
    csgTo: '3dface', // or polyline
    pathTo: 'lwpolyline',
    statusCallback: null
  }
  options = Object.assign({}, defaults, options)

  let dxfContent = `999
DXF generated by JSCAD
${dxfHeaders(options)}
${dxfClasses(options)}
${dxfTables(options)}
${dxfBlocks(options)}
${dxfEntities(objects,options)}
${dxfObjects(options)}
EOF
`
  return [dxfContent]
}

const dxfEntities = function (objects, options) {
  objects = toArray(objects)
  let entityContents = objects.map(function(object, i) {
    if (isCAG(object)) {
      let paths = object.getOutlinePaths()
      if (options.cagTo === 'polyline') {
        return PathsToPolyine(paths, options)
      }
      return PathsToLwpolyine(paths, options)
    }
    if (isCSG(object)) {
      if (options.csgTo === 'polyline') {
        return PolygonsToPolyline(object, options)
      }
      return PolygonsTo3DFaces(object, options)
    }
    if (isPath(object)) {
    // mimic a CAG outline path
      let points = object.getPoints()
      let closed = object.isClosed()
      let path = {closed: closed, points: points}
      return PathsToLwpolyine([path], options)
    }
    return ''
  })
  let section = `  0
SECTION
  2
ENTITIES
`
  entityContents.forEach(function(content) {
    if (content) {
      section += content
    }
  })
  section += `  0
ENDSEC`
  return section
}

//
// convert the given paths (from CAG outlines) to DXF lwpolyline entities
// @return array of strings
//
// Group Codes Used:
// 5 - Handle, unique HEX value, e.g. 5C6
// 8 - layer name (0 is default layer)
// 67 (0 - model space, 1 - paper space)
// 100 - 
//
const PathsToLwpolyine = function (paths, options) {
  options.statusCallback && options.statusCallback({progress: 0})
  let str = ''
  paths.map(function (path, i) {
    if (path.points.length < 1) return
    let numpointsClosed = path.points.length + (path.closed ? 1 : 0)
    str += '  0\nLWPOLYLINE\n  5\n' + getEntityId() + '\n  100\nAcDbEntity\n  8\n0\n  67\n0\n  100\nAcDbPolyline\n  90\n' + numpointsClosed + '\n  70\n' + (path.closed ? 1 : 0) + '\n'
    for (let pointindex = 0; pointindex < numpointsClosed; pointindex++) {
      let pointindexwrapped = pointindex
      if (pointindexwrapped >= path.points.length) pointindexwrapped -= path.points.length
      let point = path.points[pointindexwrapped]
      str += '  10\n' + point.x + '\n  20\n' + point.y + '\n'
    }
    options.statusCallback && options.statusCallback({progress: 100 * i / paths.length})
  })
  options.statusCallback && options.statusCallback({progress: 100})
  return [str]
}

//
// convert the given paths (from CAG outlines) to DXF polyline (2D line) entities
// @return array of strings
//
const PathsToPolyine = function (paths, options) {
  options.statusCallback && options.statusCallback({progress: 0})
  let str = ''
  paths.map(function (path, i) {
    let numpointsClosed = path.points.length + (path.closed ? 1 : 0)
    str += '  0\nPOLYLINE\n  5\n' + getEntityId() + '\n  100\nAcDbEntity\n  8\n0\n  100\nAcDb2dPolyline\n'
    for (let pointindex = 0; pointindex < numpointsClosed; pointindex++) {
      let pointindexwrapped = pointindex
      if (pointindexwrapped >= path.points.length) pointindexwrapped -= path.points.length
      let point = path.points[pointindexwrapped]
      str += '  0\nVERTEX\n  5\n' + getEntityId() + '\n  100\nAcDbEntity\n  8\n0\n  100\nAcDbVertex\n  100\nAcDb2dVertex\n 10\n' + point.x + '\n 20\n' + point.y + '\n'
    }
    str += '  0\nSEQEND\n  5\n' + getEntityId() + '\n  100\nAcDbEntity\n'
    options.statusCallback && options.statusCallback({progress: 100 * i / paths.length})
  })
  options.statusCallback && options.statusCallback({progress: 100})
  return [str]
}

//
// convert the given CSG to DXF 3D face entities
// @return array of strings
//
const PolygonsTo3DFaces = function (csg, options) {
  options.statusCallback && options.statusCallback({progress: 0})
  let str = ''
  csg.polygons.map(function (polygon, i) {
    str += '  0\n3DFACE\n  5\n' + getEntityId() + '\n  100\nAcDbEntity\n  8\n0\n  100\nAcDbFace\n  70\n0\n'
    let corner = polygon.vertices[0].pos
    str += '  10\n' + corner.x + '\n  20\n' + corner.y + '\n  30\n' + corner.z + '\n'
    corner = polygon.vertices[1].pos
    str += '  11\n' + corner.x + '\n  21\n' + corner.y + '\n  31\n' + corner.z + '\n'
    corner = polygon.vertices[2].pos
    str += '  12\n' + corner.x + '\n  22\n' + corner.y + '\n  32\n' + corner.z + '\n'
    if (polygon.vertices.length > 3) {
      corner = polygon.vertices[3].pos
    }
    str += '  13\n' + corner.x + '\n  23\n' + corner.y + '\n  33\n' + corner.z + '\n'
  })
  options.statusCallback && options.statusCallback({progress: 100})
  return [str]
}

// convert the given CSG to DXF POLYLINE (polyface mesh)
// FIXME The entity types are wrong, resulting in imterpretation as a 3D lines, not faces
// @return array of strings
const PolygonsToPolyline = function (csg, options) {
  options.statusCallback && options.statusCallback({progress: 100})
  options.statusCallback && options.statusCallback({progress: 0})
  let str = ''
  let mesh = polygons2polyfaces(csg.polygons)
  if (mesh.faces.length > 0) {
    str += '  0\nPOLYLINE\n  5\n' + getEntityId() + '\n  100\nAcDbEntity\n  8\n0\n  100\nAcDb3dPolyline\n  70\n64\n'
    str += '  71\n' + mesh.vertices.length + '\n  72\n' + mesh.faces.length + '\n'
    mesh.vertices.forEach(function (vertex) {
      str += '  0\nVERTEX\n  5\n' + getEntityId() + '\n  100\nAcDbEntity\n  8\n0\n  100\nAcDbVertex\n  100\nAcDb3dPolylineVertex\n  10\n' + vertex[0] + '\n  20\n' + vertex[1] + '\n  30\n' + vertex[2] + '\n  70\n192\n'
    })
    mesh.faces.forEach(function (face) {
      str += '  0\nVERTEX\n  5\n' + getEntityId() + '\n  100\nAcDbEntity\n  8\n0\n  100\nAcDbVertex\n  100\nAcDb3dPolylineVertex\n  10\n0\n  20\n0\n  30\n0\n  70\n128\n'
      str += '  71\n' + face[0] + '\n  72\n' + face[1] + '\n  73\n' + face[2] + '\n  74\n' + face[3] + '\n'
    })
  }
  return [str]
}

// convert the given polygons (CSG) to polyfaces (DXF)
// @return array of faces, array of vertices
const polygons2polyfaces = function (polygons) {
  var faces = []
  var vertices = []
  for(var i = 0; i < polygons.length; ++i) {
    let polygon = polygons[i]
    var face = []
    for(var j = 0; j < polygon.vertices.length; ++j) {
      var vv = polygon.vertices[j].pos;
      vertices.push([vv.x, vv.y, vv.z]);
      face.push(vertices.length)
    }
    while (face.length < 4) { face.push(0) }
    faces.push(face);
  }
  return {faces: faces, vertices: vertices};
}

var entityId = 0

function getEntityId() {
  entityId++
  // add more zeros if the id needs to be larger
  let padded = "00000" + entityId.toString(16).toUpperCase()
  return 'CAD' + padded.substr(padded.length-5)
}

function toArray (data) {
  if (Array.isArray(data)) return data
  return [data]
}

function isPath (object) {
  if (object && 'points' in object && Array.isArray(object.points)) {
    return true
  }
  return false
}

module.exports = {
  serialize,
  mimeType
}
