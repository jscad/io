const {isCAG, isCSG} = require('@jscad/csg')
const {dxfHeaders, dxfClasses, dxfTables, dxfBlocks, dxfObjects} = require('./autocad_AC2017')

const mimeType = 'application/dxf'

/**
 * Notes:
 * 1) TBD support binary output
 * 2) CAG conversion to:
 *      POLYLINE
 *      LWPOLYLINE
 * 3) CSG conversion to:
 *      3DFACE
 *      POLYLINE (polyface mesh)
 * 4) Path2D conversion to:
 *      LWPOLYLINE
 */
const serialize = function (objects, options) {
  const defaults = {
    cagTo: 'lwpolyline',
    csgTo: '3dface',
    pathTo: 'lwpolyline',
    statusCallback: null
  }
  options = Object.assign({}, defaults, options)

  let dxfContent = `999
DXF generated by JSCAD
${dxfHeaders(options)}
${dxfClasses(options)}
${dxfTables(options)}
${dxfBlocks(options)}
${dxfEntities(objects,options)}
${dxfObjects(options)}
EOF
`
  return [dxfContent]
}

const dxfEntities = function (objects, options) {
  objects = toArray(objects)
  let entityContents = objects.map(function(object, i) {
    options.handle = i
    if (isCAG(object)) {
      let paths = object.getOutlinePaths()
      if (options.cagTo === 'polyline') {
        return PathsToPolyine(paths, options)
      }
      return PathsToLwpolyine(paths, options)
    }
  })
  let content = `  0
SECTION
  2
ENTITIES
`
  entityContents.forEach(function(c) {
    content += c
  })
  content += `  0
ENDSEC`
  return content
}

//
// convert the given paths (from CAG outlines) to DXF lwpolyline entities
// @return array of strings
//
// 5 - Handle, unique HEX value, e.g. 5C6
// 8 - layer name (0 is default layer)
// 67 (0 - model space, 1 - paper space)
// 100 - 
//
const PathsToLwpolyine = function (paths, options) {
  options.statusCallback && options.statusCallback({progress: 0})
  const handle = options.handle.toString(16).toUpperCase()
  let str = ''
  paths.map(function (path, i) {
    let numpointsClosed = path.points.length + (path.closed ? 1 : 0)
    str += '  0\nLWPOLYLINE\n  5\nCAD' + handle + '\n  100\nAcDbEntity\n  8\n0\n  67\n0\n  100\nAcDbPolyline\n  90\n' + numpointsClosed + '\n  70\n' + (path.closed ? 1 : 0) + '\n'
    for (let pointindex = 0; pointindex < numpointsClosed; pointindex++) {
      let pointindexwrapped = pointindex
      if (pointindexwrapped >= path.points.length) pointindexwrapped -= path.points.length
      let point = path.points[pointindexwrapped]
      str += '  10\n' + point.x + '\n  20\n' + point.y + '\n'
    }
    options.statusCallback && options.statusCallback({progress: 100 * i / paths.length})
  })
  options.statusCallback && options.statusCallback({progress: 100})
  return [str]
}

//
// convert the given paths (from CAG outlines) to DXF polyline (2D line) entities
// @return array of strings
//
const PathsToPolyine = function (paths, options) {
  options.statusCallback && options.statusCallback({progress: 0})
  const handle = options.handle.toString(16).toUpperCase()
  const edge = 'EEE' + handle
  let str = ''
  paths.map(function (path, i) {
    let numpointsClosed = path.points.length + (path.closed ? 1 : 0)
    str += '  0\nPOLYLINE\n  5\nCAD' + handle + '\n  100\nAcDbEntity\n  8\n0\n  100\nAcDb2dPolyline\n'
    for (let pointindex = 0; pointindex < numpointsClosed; pointindex++) {
      let edgehandle = edge + pointindex.toString(16).toUpperCase()
      let pointindexwrapped = pointindex
      if (pointindexwrapped >= path.points.length) pointindexwrapped -= path.points.length
      let point = path.points[pointindexwrapped]
      str += '  0\nVERTEX\n  5\n' + edgehandle + '\n  100\nAcDbEntity\n  8\n0\n  100\nAcDbVertex\n  100\nAcDb2dVertex\n 10\n' + point.x + '\n 20\n' + point.y + '\n'
    }
    str += '  0\nSEQEND\n  5\nCAE' + handle + '\n  100\nAcDbEntity\n'
    options.statusCallback && options.statusCallback({progress: 100 * i / paths.length})
  })
  options.statusCallback && options.statusCallback({progress: 100})
  return [str]
}

function toArray (data) {
  if (Array.isArray(data)) return data
  return [data]
}

module.exports = {
  serialize,
  mimeType
}
