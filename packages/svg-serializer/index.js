/*
JSCAD Object to SVG Format Serialization

## License

Copyright (c) 2018 JSCAD Organization https://github.com/jscad

All code released under MIT license

Notes:
1) CAG conversion to:
     SVG GROUP containing a SVG PATH for each CAG outline path
2) CSG conversion to:
     mesh
3) Path2D conversion to:
     none

TBD
1) add Path2D conversion
*/

const {isCAG} = require('@jscad/csg')
const {toArray} = require('@jscad/io-utils/arrays')
const stringify = require('onml/lib/stringify')

const mimeType = 'image/svg+xml'

/** Serialize the give objects to SVG format.
 * @param {Object} [options] - options for serialization
 * @param {Object|Array} objects - objects to serialize as SVG
 * @returns {Array} serialized contents, SVG format
 */
const serialize = (...params) => {
  let options = {}
  let objects
  if (params.length === 0) {
    throw new Error('no arguments supplied to serialize function !')
  } else if (params.length === 1) {
    // assumed to be object(s)
    objects = Array.isArray(params[0]) ? params[0] : params
  } else if (params.length > 1) {
    options = params[0]
    objects = params[1]
  }
  // make sure we always deal with arrays of objects as inputs
  objects = toArray(objects)
  console.log('params', params)
  console.log('options', options)
  console.log('objects', objects)
  const defaults = {
    statusCallback: null,
    unit: 'mm', // em | ex | px | in | cm | mm | pt | pc
    decimals: 10000
  }
  options = Object.assign({}, defaults, options)

  options.statusCallback && options.statusCallback({progress: 0})

  // get the lower and upper bounds of ALL convertable objects
  var bounds = getBounds(objects)

  var width = 0
  var height = 0
  if (bounds) {
    width = Math.round((bounds[1].x - bounds[0].x) * options.decimals) / options.decimals
    height = Math.round((bounds[1].y - bounds[0].y) * options.decimals) / options.decimals
  }

  var body = ['svg',
    {
      width: width + options.unit,
      height: height + options.unit,
      viewBox: ('0 0 ' + width + ' ' + height),
      version: '1.1',
      baseProfile: 'tiny',
      xmlns: 'http://www.w3.org/2000/svg',
      'xmlns:xlink': 'http://www.w3.org/1999/xlink'
    }
  ]
  if (bounds) {
    body = body.concat(convertObjects(objects, bounds, options))
  }

  var svg = `<?xml version="1.0" encoding="UTF-8"?>
<!-- Generated by OpenJSCAD.org -->
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1 Tiny//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11-tiny.dtd">
${stringify(body)}`

  options.statusCallback && options.statusCallback({progress: 100})
  return [svg]
}

const getBounds = (objects) => {
  let bounds = null
  objects.forEach(function (object, i) {
    if (isCAG(object) && object.sides.length > 0) {
      let cagBounds = object.getBounds()
      if (bounds !== null) {
        bounds[0] = bounds[0].min(cagBounds[0])
        bounds[1] = bounds[1].max(cagBounds[1])
      } else {
        bounds = cagBounds
      }
    }
  })
  return bounds
}

const convertObjects = (objects, bounds, options) => {
  var xoffset = 0 - bounds[0].x
  var yoffset = 0 - bounds[0].y

  let contents = []
  objects.forEach(function (object, i) {
    options.statusCallback && options.statusCallback({progress: 100 * i / objects.length})
    if (isCAG(object) && object.sides.length > 0) {
      contents.push(convertCAG(object, [xoffset, yoffset], options))
    }
  })
  return contents
}

const convertCAG = (object, offsets, options) => {
  var paths = object.getOutlinePaths()
  return convertPaths(paths, offsets, options)
}

const convertPaths = (paths, offsets, options) => {
  return paths.reduce(function (res, path, i) {
    return res.concat([['path', {d: convertPath(path, offsets, options)}]])
  }, ['g'])
}

const convertPath = (path, offsets, options) => {
  var pointindex
  var str = ''
  var numpointsClosed = path.points.length + (path.closed ? 1 : 0)
  for (pointindex = 0; pointindex < numpointsClosed; pointindex++) {
    var pointindexwrapped = pointindex
    if (pointindexwrapped >= path.points.length) pointindexwrapped -= path.points.length
    var point = path.points[pointindexwrapped]
    let x = Math.round((point.x + offsets[0]) * options.decimals) / options.decimals
    let y = Math.round((point.y + offsets[1]) * options.decimals) / options.decimals
    if (pointindex > 0) {
      str += `L${x} ${y}`
    } else {
      str += `M${x} ${y}`
    }
  }
  return str
}

module.exports = {
  serialize,
  mimeType
}
